export const Golang = "# Complete Go Cheat Sheet & Pro Practices\r\n\r\n## Table of Contents\r\n\r\n1. [Basic Syntax](#basic-syntax)\r\n2. [Data Types & Variables](#data-types--variables)\r\n3. [Control Structures](#control-structures)\r\n4. [Functions](#functions)\r\n5. [Structs & Interfaces](#structs--interfaces)\r\n6. [Goroutines & Concurrency](#goroutines--concurrency)\r\n7. [Error Handling](#error-handling)\r\n8. [Packages & Modules](#packages--modules)\r\n9. [HTTP Server Development](#http-server-development)\r\n10. [Database Operations](#database-operations)\r\n11. [Testing](#testing)\r\n12. [Pro Tips & Best Practices](#pro-tips--best-practices)\r\n\r\n---\r\n\r\n## Basic Syntax\r\n\r\n### Hello World\r\n\r\n```go\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n    fmt.Println(\"Hello, World!\")\r\n}\r\n```\r\n\r\n### Variable Declaration\r\n\r\n```go\r\n// Multiple ways to declare variables\r\nvar name string = \"John\"\r\nvar age int = 25\r\nvar isActive bool = true\r\n\r\n// Short declaration (inside functions only)\r\nname := \"John\"\r\nage := 25\r\n\r\n// Multiple variables\r\nvar a, b, c int = 1, 2, 3\r\nx, y, z := 1, 2, 3\r\n```\r\n\r\n### Constants\r\n\r\n```go\r\nconst Pi = 3.14159\r\nconst (\r\n    StatusOK = 200\r\n    StatusNotFound = 404\r\n    StatusError = 500\r\n)\r\n\r\n// iota for auto-incrementing\r\nconst (\r\n    Sunday = iota    // 0\r\n    Monday          // 1\r\n    Tuesday         // 2\r\n)\r\n```\r\n\r\n---\r\n\r\n## Data Types & Variables\r\n\r\n### Basic Types\r\n\r\n```go\r\n// Numbers\r\nvar i int = 42\r\nvar f float64 = 3.14\r\nvar c complex64 = 1 + 2i\r\n\r\n// Strings\r\nvar s string = \"Hello\"\r\nvar r rune = 'A'  // Unicode code point\r\n\r\n// Boolean\r\nvar b bool = true\r\n```\r\n\r\n### Collections\r\n\r\n```go\r\n// Arrays (fixed size)\r\nvar arr [5]int = [5]int{1, 2, 3, 4, 5}\r\narr := [...]int{1, 2, 3, 4, 5}  // Auto-size\r\n\r\n// Slices (dynamic arrays)\r\nvar slice []int = []int{1, 2, 3}\r\nslice = append(slice, 4, 5)\r\nslice = slice[1:3]  // Slicing\r\n\r\n// Maps\r\nvar m map[string]int = make(map[string]int)\r\nm[\"key\"] = 42\r\ndelete(m, \"key\")\r\n\r\n// Map literal\r\nm := map[string]int{\r\n    \"apple\":  5,\r\n    \"banana\": 3,\r\n}\r\n```\r\n\r\n### Pointers\r\n\r\n```go\r\nvar p *int\r\ni := 42\r\np = &i\r\nfmt.Println(*p)  // Dereference pointer\r\n\r\n// Creating pointer with new\r\np := new(int)\r\n*p = 42\r\n```\r\n\r\n---\r\n\r\n## Control Structures\r\n\r\n### Conditionals\r\n\r\n```go\r\nif x > 0 {\r\n    fmt.Println(\"Positive\")\r\n} else if x < 0 {\r\n    fmt.Println(\"Negative\")\r\n} else {\r\n    fmt.Println(\"Zero\")\r\n}\r\n\r\n// If with statement\r\nif err := doSomething(); err != nil {\r\n    log.Fatal(err)\r\n}\r\n\r\n// Switch\r\nswitch day {\r\ncase \"Monday\":\r\n    fmt.Println(\"Start of work week\")\r\ncase \"Friday\":\r\n    fmt.Println(\"TGIF\")\r\ndefault:\r\n    fmt.Println(\"Regular day\")\r\n}\r\n\r\n// Switch without expression\r\nswitch {\r\ncase x > 0:\r\n    fmt.Println(\"Positive\")\r\ncase x < 0:\r\n    fmt.Println(\"Negative\")\r\n}\r\n```\r\n\r\n### Loops\r\n\r\n```go\r\n// For loop\r\nfor i := 0; i < 10; i++ {\r\n    fmt.Println(i)\r\n}\r\n\r\n// While-like loop\r\nfor condition {\r\n    // code\r\n}\r\n\r\n// Infinite loop\r\nfor {\r\n    break  // Exit condition\r\n}\r\n\r\n// Range over slice/array\r\nfor i, value := range slice {\r\n    fmt.Printf(\"Index: %d, Value: %d\\n\", i, value)\r\n}\r\n\r\n// Range over map\r\nfor key, value := range m {\r\n    fmt.Printf(\"Key: %s, Value: %d\\n\", key, value)\r\n}\r\n```\r\n\r\n---\r\n\r\n## Functions\r\n\r\n### Basic Functions\r\n\r\n```go\r\nfunc add(a, b int) int {\r\n    return a + b\r\n}\r\n\r\n// Multiple return values\r\nfunc divide(a, b float64) (float64, error) {\r\n    if b == 0 {\r\n        return 0, errors.New(\"division by zero\")\r\n    }\r\n    return a / b, nil\r\n}\r\n\r\n// Named return values\r\nfunc swap(x, y string) (a, b string) {\r\n    a = y\r\n    b = x\r\n    return  // naked return\r\n}\r\n```\r\n\r\n### Advanced Function Features\r\n\r\n```go\r\n// Variadic functions\r\nfunc sum(numbers ...int) int {\r\n    total := 0\r\n    for _, num := range numbers {\r\n        total += num\r\n    }\r\n    return total\r\n}\r\n\r\n// Function as type\r\ntype Calculator func(int, int) int\r\n\r\nfunc compute(fn Calculator, a, b int) int {\r\n    return fn(a, b)\r\n}\r\n\r\n// Closures\r\nfunc counter() func() int {\r\n    count := 0\r\n    return func() int {\r\n        count++\r\n        return count\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Structs & Interfaces\r\n\r\n### Structs\r\n\r\n```go\r\ntype Person struct {\r\n    Name string\r\n    Age  int\r\n}\r\n\r\n// Constructor pattern\r\nfunc NewPerson(name string, age int) *Person {\r\n    return &Person{\r\n        Name: name,\r\n        Age:  age,\r\n    }\r\n}\r\n\r\n// Methods\r\nfunc (p *Person) Greet() string {\r\n    return fmt.Sprintf(\"Hello, I'm %s\", p.Name)\r\n}\r\n\r\n// Embedded structs\r\ntype Employee struct {\r\n    Person\r\n    ID       int\r\n    Position string\r\n}\r\n```\r\n\r\n### Interfaces\r\n\r\n```go\r\ntype Writer interface {\r\n    Write([]byte) (int, error)\r\n}\r\n\r\ntype Stringer interface {\r\n    String() string\r\n}\r\n\r\n// Interface implementation\r\nfunc (p Person) String() string {\r\n    return fmt.Sprintf(\"%s (%d years old)\", p.Name, p.Age)\r\n}\r\n\r\n// Empty interface\r\nfunc printAnything(v interface{}) {\r\n    fmt.Println(v)\r\n}\r\n\r\n// Type assertion\r\nif s, ok := v.(string); ok {\r\n    fmt.Println(\"String:\", s)\r\n}\r\n\r\n// Type switch\r\nswitch v := v.(type) {\r\ncase string:\r\n    fmt.Println(\"String:\", v)\r\ncase int:\r\n    fmt.Println(\"Integer:\", v)\r\ndefault:\r\n    fmt.Println(\"Unknown type\")\r\n}\r\n```\r\n\r\n---\r\n\r\n## Goroutines & Concurrency\r\n\r\n### Goroutines\r\n\r\n```go\r\n// Start a goroutine\r\ngo func() {\r\n    fmt.Println(\"Running in goroutine\")\r\n}()\r\n\r\n// Wait for goroutines\r\nvar wg sync.WaitGroup\r\nwg.Add(2)\r\n\r\ngo func() {\r\n    defer wg.Done()\r\n    // work\r\n}()\r\n\r\ngo func() {\r\n    defer wg.Done()\r\n    // work\r\n}()\r\n\r\nwg.Wait()\r\n```\r\n\r\n### Channels\r\n\r\n```go\r\n// Create channel\r\nch := make(chan int)\r\nbuffered := make(chan int, 10)\r\n\r\n// Send and receive\r\ngo func() {\r\n    ch <- 42\r\n}()\r\nvalue := <-ch\r\n\r\n// Channel directions\r\nfunc sender(ch chan<- int) {\r\n    ch <- 42\r\n}\r\n\r\nfunc receiver(ch <-chan int) {\r\n    value := <-ch\r\n    fmt.Println(value)\r\n}\r\n\r\n// Select statement\r\nselect {\r\ncase msg1 := <-ch1:\r\n    fmt.Println(\"Received from ch1:\", msg1)\r\ncase msg2 := <-ch2:\r\n    fmt.Println(\"Received from ch2:\", msg2)\r\ncase <-time.After(1 * time.Second):\r\n    fmt.Println(\"Timeout\")\r\ndefault:\r\n    fmt.Println(\"No communication\")\r\n}\r\n```\r\n\r\n### Sync Primitives\r\n\r\n```go\r\n// Mutex\r\nvar mu sync.Mutex\r\nvar counter int\r\n\r\nfunc increment() {\r\n    mu.Lock()\r\n    defer mu.Unlock()\r\n    counter++\r\n}\r\n\r\n// RWMutex\r\nvar rwmu sync.RWMutex\r\nvar data map[string]int\r\n\r\nfunc readData(key string) int {\r\n    rwmu.RLock()\r\n    defer rwmu.RUnlock()\r\n    return data[key]\r\n}\r\n\r\n// Once\r\nvar once sync.Once\r\n\r\nfunc initialize() {\r\n    once.Do(func() {\r\n        fmt.Println(\"Initialized once\")\r\n    })\r\n}\r\n```\r\n\r\n---\r\n\r\n## Error Handling\r\n\r\n### Basic Error Handling\r\n\r\n```go\r\nfunc divide(a, b float64) (float64, error) {\r\n    if b == 0 {\r\n        return 0, errors.New(\"division by zero\")\r\n    }\r\n    return a / b, nil\r\n}\r\n\r\n// Check errors\r\nresult, err := divide(10, 0)\r\nif err != nil {\r\n    log.Fatal(err)\r\n}\r\n```\r\n\r\n### Custom Errors\r\n\r\n```go\r\ntype ValidationError struct {\r\n    Field string\r\n    Value string\r\n}\r\n\r\nfunc (e *ValidationError) Error() string {\r\n    return fmt.Sprintf(\"invalid %s: %s\", e.Field, e.Value)\r\n}\r\n\r\n// Error wrapping (Go 1.13+)\r\nimport \"fmt\"\r\n\r\nfunc processFile(filename string) error {\r\n    err := openFile(filename)\r\n    if err != nil {\r\n        return fmt.Errorf(\"failed to process %s: %w\", filename, err)\r\n    }\r\n    return nil\r\n}\r\n\r\n// Error unwrapping\r\nif errors.Is(err, ErrNotFound) {\r\n    // handle not found\r\n}\r\n\r\nvar validationErr *ValidationError\r\nif errors.As(err, &validationErr) {\r\n    // handle validation error\r\n}\r\n```\r\n\r\n---\r\n\r\n## Packages & Modules\r\n\r\n### Package Structure\r\n\r\n```go\r\n// main.go\r\npackage main\r\n\r\nimport (\r\n    \"fmt\"\r\n    \"myproject/internal/user\"\r\n    \"github.com/gin-gonic/gin\"\r\n)\r\n\r\n// user/user.go\r\npackage user\r\n\r\ntype User struct {\r\n    ID   int\r\n    Name string\r\n}\r\n\r\nfunc NewUser(name string) *User {\r\n    return &User{Name: name}\r\n}\r\n```\r\n\r\n### Go Modules\r\n\r\n```bash\r\n# Initialize module\r\ngo mod init myproject\r\n\r\n# Add dependency\r\ngo get github.com/gin-gonic/gin\r\n\r\n# Update dependencies\r\ngo mod tidy\r\n\r\n# Vendor dependencies\r\ngo mod vendor\r\n```\r\n\r\n---\r\n\r\n## HTTP Server Development\r\n\r\n### Basic HTTP Server\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n    \"encoding/json\"\r\n    \"log\"\r\n    \"net/http\"\r\n)\r\n\r\ntype User struct {\r\n    ID   int    `json:\"id\"`\r\n    Name string `json:\"name\"`\r\n}\r\n\r\nfunc main() {\r\n    http.HandleFunc(\"/users\", usersHandler)\r\n    http.HandleFunc(\"/users/\", userHandler)\r\n\r\n    log.Println(\"Server starting on :8080\")\r\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\r\n}\r\n\r\nfunc usersHandler(w http.ResponseWriter, r *http.Request) {\r\n    switch r.Method {\r\n    case http.MethodGet:\r\n        getUsers(w, r)\r\n    case http.MethodPost:\r\n        createUser(w, r)\r\n    default:\r\n        http.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\r\n    }\r\n}\r\n```\r\n\r\n### Advanced HTTP Server with Middleware\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n    \"context\"\r\n    \"log\"\r\n    \"net/http\"\r\n    \"strings\"\r\n    \"time\"\r\n)\r\n\r\n// Middleware type\r\ntype Middleware func(http.Handler) http.Handler\r\n\r\n// Logger middleware\r\nfunc Logger(next http.Handler) http.Handler {\r\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\r\n        start := time.Now()\r\n        next.ServeHTTP(w, r)\r\n        log.Printf(\"%s %s %v\", r.Method, r.URL.Path, time.Since(start))\r\n    })\r\n}\r\n\r\n// Auth middleware\r\nfunc Auth(next http.Handler) http.Handler {\r\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\r\n        token := r.Header.Get(\"Authorization\")\r\n        if token == \"\" {\r\n            http.Error(w, \"Unauthorized\", http.StatusUnauthorized)\r\n            return\r\n        }\r\n\r\n        // Add user to context\r\n        ctx := context.WithValue(r.Context(), \"user\", getUserFromToken(token))\r\n        next.ServeHTTP(w, r.WithContext(ctx))\r\n    })\r\n}\r\n\r\n// Chain middlewares\r\nfunc Chain(middlewares ...Middleware) Middleware {\r\n    return func(next http.Handler) http.Handler {\r\n        for i := len(middlewares) - 1; i >= 0; i-- {\r\n            next = middlewares[i](next)\r\n        }\r\n        return next\r\n    }\r\n}\r\n\r\n// Usage\r\nfunc main() {\r\n    mux := http.NewServeMux()\r\n    mux.HandleFunc(\"/api/users\", usersHandler)\r\n\r\n    handler := Chain(Logger, Auth)(mux)\r\n\r\n    server := &http.Server{\r\n        Addr:         \":8080\",\r\n        Handler:      handler,\r\n        ReadTimeout:  15 * time.Second,\r\n        WriteTimeout: 15 * time.Second,\r\n    }\r\n\r\n    log.Fatal(server.ListenAndServe())\r\n}\r\n```\r\n\r\n### JSON API with Validation\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n    \"encoding/json\"\r\n    \"fmt\"\r\n    \"net/http\"\r\n    \"strconv\"\r\n    \"strings\"\r\n)\r\n\r\ntype CreateUserRequest struct {\r\n    Name  string `json:\"name\" validate:\"required\"`\r\n    Email string `json:\"email\" validate:\"required,email\"`\r\n}\r\n\r\ntype User struct {\r\n    ID    int    `json:\"id\"`\r\n    Name  string `json:\"name\"`\r\n    Email string `json:\"email\"`\r\n}\r\n\r\nfunc createUser(w http.ResponseWriter, r *http.Request) {\r\n    var req CreateUserRequest\r\n\r\n    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {\r\n        http.Error(w, \"Invalid JSON\", http.StatusBadRequest)\r\n        return\r\n    }\r\n\r\n    // Validate request\r\n    if err := validateCreateUserRequest(req); err != nil {\r\n        http.Error(w, err.Error(), http.StatusBadRequest)\r\n        return\r\n    }\r\n\r\n    // Create user\r\n    user := User{\r\n        ID:    generateID(),\r\n        Name:  req.Name,\r\n        Email: req.Email,\r\n    }\r\n\r\n    w.Header().Set(\"Content-Type\", \"application/json\")\r\n    json.NewEncoder(w).Encode(user)\r\n}\r\n\r\nfunc validateCreateUserRequest(req CreateUserRequest) error {\r\n    if req.Name == \"\" {\r\n        return fmt.Errorf(\"name is required\")\r\n    }\r\n    if req.Email == \"\" {\r\n        return fmt.Errorf(\"email is required\")\r\n    }\r\n    if !strings.Contains(req.Email, \"@\") {\r\n        return fmt.Errorf(\"invalid email format\")\r\n    }\r\n    return nil\r\n}\r\n```\r\n\r\n---\r\n\r\n## Database Operations\r\n\r\n### SQL Database (PostgreSQL)\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n    \"database/sql\"\r\n    \"log\"\r\n\r\n    _ \"github.com/lib/pq\"\r\n)\r\n\r\ntype User struct {\r\n    ID    int\r\n    Name  string\r\n    Email string\r\n}\r\n\r\ntype UserRepo struct {\r\n    db *sql.DB\r\n}\r\n\r\nfunc NewUserRepo(db *sql.DB) *UserRepo {\r\n    return &UserRepo{db: db}\r\n}\r\n\r\nfunc (r *UserRepo) Create(user *User) error {\r\n    query := `\r\n        INSERT INTO users (name, email)\r\n        VALUES ($1, $2)\r\n        RETURNING id`\r\n\r\n    err := r.db.QueryRow(query, user.Name, user.Email).Scan(&user.ID)\r\n    return err\r\n}\r\n\r\nfunc (r *UserRepo) GetByID(id int) (*User, error) {\r\n    user := &User{}\r\n    query := `SELECT id, name, email FROM users WHERE id = $1`\r\n\r\n    err := r.db.QueryRow(query, id).Scan(&user.ID, &user.Name, &user.Email)\r\n    if err != nil {\r\n        return nil, err\r\n    }\r\n    return user, nil\r\n}\r\n\r\nfunc (r *UserRepo) List() ([]*User, error) {\r\n    query := `SELECT id, name, email FROM users`\r\n    rows, err := r.db.Query(query)\r\n    if err != nil {\r\n        return nil, err\r\n    }\r\n    defer rows.Close()\r\n\r\n    var users []*User\r\n    for rows.Next() {\r\n        user := &User{}\r\n        err := rows.Scan(&user.ID, &user.Name, &user.Email)\r\n        if err != nil {\r\n            return nil, err\r\n        }\r\n        users = append(users, user)\r\n    }\r\n    return users, nil\r\n}\r\n\r\n// Connection setup\r\nfunc setupDB() (*sql.DB, error) {\r\n    db, err := sql.Open(\"postgres\", \"postgres://user:password@localhost/mydb?sslmode=disable\")\r\n    if err != nil {\r\n        return nil, err\r\n    }\r\n\r\n    db.SetMaxOpenConns(10)\r\n    db.SetMaxIdleConns(5)\r\n\r\n    return db, nil\r\n}\r\n```\r\n\r\n### Context and Transactions\r\n\r\n```go\r\nfunc (r *UserRepo) CreateWithContext(ctx context.Context, user *User) error {\r\n    query := `INSERT INTO users (name, email) VALUES ($1, $2) RETURNING id`\r\n    err := r.db.QueryRowContext(ctx, query, user.Name, user.Email).Scan(&user.ID)\r\n    return err\r\n}\r\n\r\nfunc (r *UserRepo) UpdateUserAndLog(ctx context.Context, user *User) error {\r\n    tx, err := r.db.BeginTx(ctx, nil)\r\n    if err != nil {\r\n        return err\r\n    }\r\n    defer tx.Rollback()\r\n\r\n    // Update user\r\n    _, err = tx.ExecContext(ctx, \"UPDATE users SET name=$1, email=$2 WHERE id=$3\",\r\n        user.Name, user.Email, user.ID)\r\n    if err != nil {\r\n        return err\r\n    }\r\n\r\n    // Log the update\r\n    _, err = tx.ExecContext(ctx, \"INSERT INTO user_logs (user_id, action) VALUES ($1, $2)\",\r\n        user.ID, \"updated\")\r\n    if err != nil {\r\n        return err\r\n    }\r\n\r\n    return tx.Commit()\r\n}\r\n```\r\n\r\n---\r\n\r\n## Testing\r\n\r\n### Unit Tests\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n    \"testing\"\r\n    \"reflect\"\r\n)\r\n\r\nfunc TestAdd(t *testing.T) {\r\n    result := add(2, 3)\r\n    expected := 5\r\n\r\n    if result != expected {\r\n        t.Errorf(\"add(2, 3) = %d; want %d\", result, expected)\r\n    }\r\n}\r\n\r\nfunc TestAddTable(t *testing.T) {\r\n    tests := []struct {\r\n        name     string\r\n        a, b     int\r\n        expected int\r\n    }{\r\n        {\"positive numbers\", 2, 3, 5},\r\n        {\"negative numbers\", -2, -3, -5},\r\n        {\"zero\", 0, 5, 5},\r\n    }\r\n\r\n    for _, tt := range tests {\r\n        t.Run(tt.name, func(t *testing.T) {\r\n            result := add(tt.a, tt.b)\r\n            if result != tt.expected {\r\n                t.Errorf(\"add(%d, %d) = %d; want %d\", tt.a, tt.b, result, tt.expected)\r\n            }\r\n        })\r\n    }\r\n}\r\n```\r\n\r\n### HTTP Testing\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n    \"net/http\"\r\n    \"net/http/httptest\"\r\n    \"strings\"\r\n    \"testing\"\r\n)\r\n\r\nfunc TestUsersHandler(t *testing.T) {\r\n    req := httptest.NewRequest(http.MethodGet, \"/users\", nil)\r\n    w := httptest.NewRecorder()\r\n\r\n    usersHandler(w, req)\r\n\r\n    if w.Code != http.StatusOK {\r\n        t.Errorf(\"Expected status %d, got %d\", http.StatusOK, w.Code)\r\n    }\r\n\r\n    expected := `[{\"id\":1,\"name\":\"John\"}]`\r\n    if strings.TrimSpace(w.Body.String()) != expected {\r\n        t.Errorf(\"Expected body %s, got %s\", expected, w.Body.String())\r\n    }\r\n}\r\n```\r\n\r\n### Benchmarks\r\n\r\n```go\r\nfunc BenchmarkAdd(b *testing.B) {\r\n    for i := 0; i < b.N; i++ {\r\n        add(2, 3)\r\n    }\r\n}\r\n\r\nfunc BenchmarkStringBuilder(b *testing.B) {\r\n    for i := 0; i < b.N; i++ {\r\n        var builder strings.Builder\r\n        for j := 0; j < 1000; j++ {\r\n            builder.WriteString(\"test\")\r\n        }\r\n        _ = builder.String()\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Pro Tips & Best Practices\r\n\r\n### Code Organization\r\n\r\n```go\r\n// Use clear package structure\r\nmyproject/\r\n├── cmd/\r\n│   └── server/\r\n│       └── main.go\r\n├── internal/\r\n│   ├── user/\r\n│   │   ├── handler.go\r\n│   │   ├── service.go\r\n│   │   └── repository.go\r\n│   └── config/\r\n│       └── config.go\r\n├── pkg/\r\n│   └── middleware/\r\n│       └── auth.go\r\n├── go.mod\r\n└── go.sum\r\n```\r\n\r\n### Error Handling Best Practices\r\n\r\n```go\r\n// Don't ignore errors\r\nresult, err := doSomething()\r\nif err != nil {\r\n    return fmt.Errorf(\"failed to do something: %w\", err)\r\n}\r\n\r\n// Use sentinel errors\r\nvar ErrNotFound = errors.New(\"not found\")\r\n\r\n// Custom error types\r\ntype ValidationError struct {\r\n    Field string\r\n    Value interface{}\r\n}\r\n\r\nfunc (e ValidationError) Error() string {\r\n    return fmt.Sprintf(\"validation failed for field %s: %v\", e.Field, e.Value)\r\n}\r\n```\r\n\r\n### Performance Tips\r\n\r\n```go\r\n// Use string builder for concatenation\r\nvar builder strings.Builder\r\nfor _, s := range strings {\r\n    builder.WriteString(s)\r\n}\r\nresult := builder.String()\r\n\r\n// Pre-allocate slices when size is known\r\nitems := make([]Item, 0, expectedSize)\r\n\r\n// Use buffered channels for producer-consumer\r\nch := make(chan Item, 100)\r\n\r\n// Pool expensive objects\r\nvar pool = sync.Pool{\r\n    New: func() interface{} {\r\n        return &ExpensiveObject{}\r\n    },\r\n}\r\n\r\nobj := pool.Get().(*ExpensiveObject)\r\ndefer pool.Put(obj)\r\n```\r\n\r\n### Configuration Management\r\n\r\n```go\r\npackage config\r\n\r\nimport (\r\n    \"os\"\r\n    \"strconv\"\r\n)\r\n\r\ntype Config struct {\r\n    Port        int\r\n    DatabaseURL string\r\n    JWTSecret   string\r\n}\r\n\r\nfunc Load() (*Config, error) {\r\n    port, err := strconv.Atoi(getEnv(\"PORT\", \"8080\"))\r\n    if err != nil {\r\n        return nil, err\r\n    }\r\n\r\n    return &Config{\r\n        Port:        port,\r\n        DatabaseURL: getEnv(\"DATABASE_URL\", \"\"),\r\n        JWTSecret:   getEnv(\"JWT_SECRET\", \"\"),\r\n    }, nil\r\n}\r\n\r\nfunc getEnv(key, defaultValue string) string {\r\n    if value := os.Getenv(key); value != \"\" {\r\n        return value\r\n    }\r\n    return defaultValue\r\n}\r\n```\r\n\r\n### Graceful Shutdown\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n    \"context\"\r\n    \"log\"\r\n    \"net/http\"\r\n    \"os\"\r\n    \"os/signal\"\r\n    \"syscall\"\r\n    \"time\"\r\n)\r\n\r\nfunc main() {\r\n    server := &http.Server{\r\n        Addr:    \":8080\",\r\n        Handler: setupRoutes(),\r\n    }\r\n\r\n    // Start server in goroutine\r\n    go func() {\r\n        if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {\r\n            log.Fatal(\"Server failed to start:\", err)\r\n        }\r\n    }()\r\n\r\n    // Wait for interrupt signal\r\n    quit := make(chan os.Signal, 1)\r\n    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\r\n    <-quit\r\n\r\n    log.Println(\"Shutting down server...\")\r\n\r\n    // Graceful shutdown with timeout\r\n    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\r\n    defer cancel()\r\n\r\n    if err := server.Shutdown(ctx); err != nil {\r\n        log.Fatal(\"Server forced to shutdown:\", err)\r\n    }\r\n\r\n    log.Println(\"Server exited\")\r\n}\r\n```\r\n\r\n### Common Patterns\r\n\r\n```go\r\n// Option pattern\r\ntype Server struct {\r\n    port int\r\n    host string\r\n}\r\n\r\ntype Option func(*Server)\r\n\r\nfunc WithPort(port int) Option {\r\n    return func(s *Server) {\r\n        s.port = port\r\n    }\r\n}\r\n\r\nfunc WithHost(host string) Option {\r\n    return func(s *Server) {\r\n        s.host = host\r\n    }\r\n}\r\n\r\nfunc NewServer(opts ...Option) *Server {\r\n    s := &Server{\r\n        port: 8080,\r\n        host: \"localhost\",\r\n    }\r\n\r\n    for _, opt := range opts {\r\n        opt(s)\r\n    }\r\n\r\n    return s\r\n}\r\n\r\n// Usage\r\nserver := NewServer(\r\n    WithPort(9000),\r\n    WithHost(\"0.0.0.0\"),\r\n)\r\n```\r\n\r\n### Key Takeaways\r\n\r\n1. **Always handle errors** - Don't ignore them\r\n2. **Use interfaces** - Make your code testable and flexible\r\n3. **Prefer composition over inheritance** - Embed structs when needed\r\n4. **Use context** - For cancellation and request-scoped values\r\n5. **Write tests** - Unit tests and integration tests\r\n6. **Profile your code** - Use `go tool pprof` for performance analysis\r\n7. **Keep packages small** - Single responsibility principle\r\n8. **Use golint and go vet** - Maintain code quality\r\n9. **Document public APIs** - Write clear godoc comments\r\n10. **Think about concurrency** - Use goroutines and channels effectively\r\n\r\n---\r\n\r\nThis cheat sheet covers the essential Go concepts and patterns you'll need for both general programming and server development. Remember to always refer to the official Go documentation for the most up-to-date information.\r\n";
